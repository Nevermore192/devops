# Podman

Інструмент з відкритим вихідним кодом для пошуку, складання, передачі та запуску програм. Є утилітою командного рядка з аналогічними командами docker, проте не вимагає додатковий сервіс для роботи і може працювати без прав доступу root. За замовчуванням використовує як Container Runtime crun (раніше runc)

Systemd: У Linux системах Podman може взаємодіяти з системним менеджером systemd для керування контейнерами як службами. Це дозволяє автоматизувати запуск та управління контейнерами під час завантаження системи або після її завершення.

OCI (Open Container Initiative): Podman використовує стандарти OCI для опису контейнерів та їхнього виконання. Це дозволяє забезпечити сумісність з іншими контейнерними інструментами та образами, що також підтримують стандарти OCI.

## Плюси podman

- Безпека: Podman підтримує безпеку на рівні контейнерів, і він не вимагає використання демона, що запускається з привілеями. Це допомагає уникнути потенційних загроз безпеці, пов'язаних з використанням демона Docker.
- Сумісність: Podman намагається бути сумісним з командами Docker, що дозволяє переносити існуючий код та скрипти без великих змін.
- Підтримка rootless контейнерів: Ви можете створювати та запускати контейнери без потреби в привілеях root, що підвищує безпеку та дозволяє користувачам запускати контейнери безпечніше.
- Можливість працювати зі сховищами образів Docker: Podman може використовувати існуючі образи Docker та публічні сховища, що робить перехід з Docker до Podman легше.
- Налаштувати переміщення не тільки образів контейнерів, але і переходів в кібернетіс. Тобто якщо почати роботу з кібернетіс або перенести своє робоче навантаження на кібернетіса в ролі окрестратора , тоді подмен найкращий вибір.

## Мінуси podman

- Обмеження функціональності: У деяких випадках, Podman може не мати всіх функцій, які доступні в Docker, особливо коли мова йде про продуктивність та спеціалізовані налаштування.
- Спрощена мережева модель: Podman має більш просту мережеву модель порівняно з Docker, що може бути недостатньою для деяких вимог.

## Мультиконтейнерные приложения (Podman Compose и Podman Pod) а також podman Desktop

Podman Compose – це інструмент для декларативного опису та запуску програм, що складаються з кількох контейнерів. Фактично Podman Compose є нічим іншим, як реалізація Docker Compose для Podman з урахуванням його особливостей (наприклад, можливості працювати з контейнерами без прав доступу root). Він використовує yaml файл для налаштування сервісів програми та виконує процес створення та запуску всіх контейнерів за допомогою однієї команди.

Podman Desktop — це офіційний графічний інтерфейс для роботи Podman. Окрім обгортки Podman CLI, він містить додаткові функції, включаючи інтеграцію з Kubernetes та розширення сторонніх розробників. Ви можете використовувати Desktop для зручної взаємодії з контейнерами та пов’язаними ресурсами на вашій робочій станції, якщо ви не хочете виконувати команди терміналу.

## Podman vs docker

1. Архітектура:
    - Docker використовує демон (Docker Daemon), який працює як служба з привілеями та керує контейнерами.
    - Podman, навпаки, працює без демона і не потребує привілеїв root для свого запуску. Кожен контейнер у Podman запускається в окремому процесі.
2. Безпека:
    - Podman має безпечну архітектуру, оскільки не вимагає демона та дозволів root для запуску контейнерів.
    - Docker може бути менш безпечним через використання демона, який має доступ до системи з привілеями root.
3. Сумісність:
    - Podman намагається бути сумісним з командами Docker, і багато команд Docker можна використовувати без змін в Podman.
    - Docker власний документний файл має більшу популярність і багато інструментів і ресурсів присвячені саме Docker.
4. Rootless контейнери:
    - Підтримка rootless контейнерів є в обох інструментах, але Podman відзначається своєю простотою і швидкістю налаштування цієї функції.
5. Підтримка Windows і macOS:
    - Docker надає можливість запускати контейнери на Windows та macOS через Docker Desktop.
    - Podman призначений для використання в Linux-середовищі, але для інших середовищ він також підтримується через podman desctop
6. Мережева модель:
    - Docker має більш розвинуту мережеву модель з багатьма додатковими можливостями.
    - Podman має спрощену мережеву модель, що може бути достатньою для багатьох випадків використання.

## О**сновні ключові особливості** Podman Desktop виділяє наступне:

- Кросплатформенний, можна встановити та запускати на Windows, macOS та Linux
- Налаштувати та встановити через Podman, Kind, Red Hat OpenShift Local, Developer Sandbox для Red Hat OpenShift
- Дозволяє створювати, запускати, керувати та налагоджувати контейнери та модулі
- Ви можете запускати модулі з Kubernetes або без нього
- Він має вбудований термінал для доступу до контейнерів
- Дозволяє керувати кількома двигунами контейнерів
- Сумісний із Docker Compose
- Давайте запустимо Kubernetes YAML
- Створіть Kubernetes YAML із Pods
- Podify і Kubify: перетворюйте контейнери на модулі та Kubernetes
- Налаштування VPN і проксі
- Управління реєстрацією зображень
- Налаштування кількох записів OCI
- Установка з повітряним зазором
- Міст між локальним і віддаленим середовищем
- Вмикає віддалено керовані служби локально
- Розширюваність

## Приклад налаштування VPN системи на podman

Створюємо образ OpenVPN

- podman pull kylemanna/openvpn

Створюємо каталог для зберігання конфігурацій OpenVPN:

- mkdir -p ./openvpn-data

Запуск контейнера OpenVPN та ініціалізація конфігурації

- podman run -v ./openvpn-data:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://vpn.example.com ( замінити на домен, або IP-адрес)

Створити сертифікат та ключі для  OpenVPN:

- podman run -v ./openvpn-data:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki

Запустити контейнер OpenVPN:

- podman run -v ./openvpn-data:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn

Опція **--cap-add=NET_ADMIN** необхідна для надання контейнеру доступу до мережевих операцій.

Після чого надається можливість конфігоруватм свій клієнт OpenVPN

### Основні команди podman:

- podman --help # **список доступних команд**
- podman <command> --help # **інформація по команді**
- podman search nginx # **пошук образів за ключовим словом nginx**
- podman pull ubuntu # **скачування останньої версії**
- podman pull [quay.io/bitnami/nginx:latest](http://quay.io/bitnami/nginx:latest) # **скачування останньої версії образу nginx**
- podman pull [docker.io/library/ubuntu:18.04](http://docker.io/library/ubuntu:18.04) # **скачування з репозиторію docker.io**
- podman images # **перегляд локальних образів**
- podman rmi <image_name>:<tag> # **видалення образу.**
- podman rmi --all # **видалення всіх образів**
- podman run hello-world # Hello, world!  - написання перевірки
- podman run -it ubuntu bash # **запуск контейнера ubuntu та виконання команди bash**
- podman run --detach --name nginx --publish 9090:8080 [quay.io/bitnami/nginx:1.20.2](http://quay.io/bitnami/nginx:1.20.2) # запуск
- podman run --detach --name mongodb [docker.io/library/mongo:4.4.10](http://docker.io/library/mongo:4.4.10) запуск
- podman start <container_name> # **запуск створеного контейнера. Замість** <container_name> **можна вказати** <container_id>
- podman start --all # **запуск усіх створених контейнерів**
- podman stop <container_name> # зупинка контейнера. Замість <container_name> можна вказати <container_id>
- podman stop --all # **зупинка всіх контейнерів**
- podman rm <container_name> # **видалення контейнера.**
- podman rm --all # **видалення всіх контейнерів**
- podman system info # **загальна інформація про систему**
- podman system df # **зайняте місце на диску**
- podman system prune -af # **видалення невикористовуваних даних та очищення диска**

# Containerd

containerd - це колишня частина Docker, а нині самостійне рішення, що реалізує виконуване середовище для запуску контейнерів. При його створенні, як стверджують розробники, вони прагнули до простоти, надійності та портованості.

"Фізично" це демон на хост-системі, який керує всім життєвим циклом контейнера: від отримання і зберігання образу до запуску контейнера (через runC - докладніше див. нижче) і контролю його роботи. З демоном containerd можна взаємодіяти за низькорівневим gRPC API через локальний UNIX-сокет, а для експериментів і налагодження також доступна консольна утиліта ctr

Containerd використовує стандарти OCI (Open Container Initiative) для опису та виконання контейнерів. Це означає, що він підтримує специфікації, які забезпечують сумісність з іншими контейнерними інструментами та образами, що також підтримують стандарти OCI.

## Плюси Containerd

- Висока продуктивність: Containerd має високу продуктивність і швидкість завантаження контейнерів. Це важливо для сценаріїв, де вимагається швидке створення та запуск контейнерів.
- Мережеві можливості: Він надає можливості для налаштування мережевої моделі контейнерів, включаючи створення мережевих інтерфейсів, встановлення правил файрвола та підтримку різних мережевих плагінів. Це дозволяє налаштовувати мережеві аспекти контейнерів з високою гнучкістю.
- Підтримка rootless контейнерів: Containerd підтримує можливість запуску контейнерів без привілеїв root. Це покращує безпеку і дозволяє користувачам запускати контейнери без ризику надання привілеїв root.
- Розширеність: Containerd є розширюваним і підтримує плагіни для різних завдань, що дозволяє розширити його функціональність для конкретних потреб і сценаріїв.
- Безпека: Використання Containerd може підвищити безпеку, оскільки він дозволяє обмежувати доступ до системи від контейнерів і ізолювати їхні процеси від хост-системи.

## Мінуси Containerd

Containerd є низькорівневим компонентом для керування контейнерами, і багато з його "недоліків" можуть виникати лише при прямому використанні його API, а не як користувачевого інструменту. 

- Складність використання: Використання Containerd без вищорівневих інструментів, таких як Docker або Kubernetes, може бути складним і вимагати ручного виконання багатьох операцій для керування контейнерами.
- Відсутність інтерактивного інтерфейсу: Containerd не надає користувачевого інтерфейсу для взаємодії з контейнерами безпосередньо. Для користувача це означає, що вам може знадобитися інший інструмент для комфортного користування.
- Відсутність додаткових можливостей: Containerd надає базовий набір функцій для керування контейнерами, і вам, можливо, доведеться використовувати інші інструменти або плагіни, щоб отримати розширені функціональність, такі як моніторинг, мережеві налаштування тощо.
- Низький рівень абстракції: Containerd працює на низькому рівні інфраструктури і може бути складним для новачків в контейнерному просторі.
- Вимоги до додаткового програмного забезпечення: Для повноцінного використання Containerd, вам може знадобитися додаткове програмне забезпечення для керування, моніторингу, мережевого налаштування та інших аспектів контейнерів.

## Порівняння між Docker  та containerd

1. Рівень абстракції:
    - Docker - це вищорівневий інструмент для керування контейнерами, який надає інтерфейс для створення, запуску та управління контейнерами. Він також містить більше вбудованих функцій для роботи з образами та мережами.
    - Containerd - це низькорівневий компонент для керування контейнерами, який надає базові операції для створення та запуску контейнерів. Він є менш абстрактним і потребує вищорівневих інструментів для повноцінного використання.
2. Сумісність з OCI:
    - Як Docker, так і Containerd використовують стандарти OCI для опису та виконання контейнерів, що дозволяє їм бути сумісними з іншими інструментами та образами, які підтримують стандарти OCI.
3. Безпека:
    - Containerd допомагає забезпечити безпеку, оскільки він може бути використаний для ізоляції процесів контейнера та обмеження їхнього доступу до хост-системи.
    - Docker може бути менш безпечним через використання демона Docker, який має доступ до системи з привілеями root.
4. Сумісність і популярність:
    - Docker є більш популярним та відомим інструментом з більшою кількістю ресурсів, документації та спільноти користувачів.
    - Containerd є менш популярним і може вимагати більше ручних дій та налаштувань для користувачів.
5. Мережева модель:
    - Docker має більш розвинуту мережеву модель з багатьма додатковими можливостями.
    - Containerd має спрощену мережеву модель, що може бути достатньою для багатьох випадків використання.
6. Rootless контейнери:
    - Як Docker, так і Containerd підтримують можливість запуску контейнерів без привілеїв root, що підвищує безпеку та ізоляцію.

## Властивості та команди

Docker може бути кращим варіантом для користувачів, які шукають готовий та повний функціонал, тоді як Containerd може бути вигідним для тих, хто більше цінує безпеку та мінімальну абстракцію. 

Також слід зазначити, що команди між Docker та Containerd являються схожими.

Серед основних влставостей слід зазначити:

- containerd container create - Створення контейнера
- containerd container start <container-id> - Старт контейнера
- containerd container stop <container-id> - Зупинка контейнера
- containerd container delete <container-id> - Видалення контейнера
- containerd container list - список всіх контейнерів
- containerd container inspect <container-id> - Інформація про контейнер
- containerd snapshot create <snapshot-id> <container-id> - створення snaphot
- containerd container restore <container-id> --snapshot <snapshot-id> - Відновлення   контейнера з snaphot
- containerd image import <image-path> - Завантаження образу контейнера
- containerd image list - Список всіх образів контейнера
- containerd image inspect <image-id> - Інформація про образ контейнера
- containerd image delete <image-id> - Видалення образу контейнера
- containerd task list - Список доступних тасків (задач)
- containerd task inspect <task-id> - Інформація про таск (задачу)
- containerd events - Виведення журналу подій

## Основні властивості архітектури

- Containerd Daemon: Containerd Daemon, також відомий як **`containerd`**, це центральний компонент, який відповідає за керування контейнерами. Він приймає запити через API, взаємодіє з іншими компонентами та виконує команди для створення, запуску, зупинки та видалення контейнерів.
- Shims: Shims - це процеси, які використовуються для запуску контейнерів. Вони допомагають ізолювати процеси контейнера та забезпечують взаємодію з Containerd Daemon. Шімі забезпечують взаємодію з ізольованим середовищем контейнера, включаючи мережеві операції, введення/виведення, моніторинг тощо.
- RunC: RunC - це стандартний виконавчий інструмент, який використовується Containerd для запуску контейнерів відповідно до стандартів OCI (Open Container Initiative). RunC відповідає за створення окремого процесу контейнера та запуск процесів контейнера у відокремленому середовищі.

## Взаємодія з VPN

Можна налаштувати контейнери для використання мережевого простору VPN. Можливо. налаштувати мережевий стек внутрішнього простору VPN для контейнерів, щоб вони використовували VPN для з'єднання з іншими контейнерами або мережами. Але Docker compose для цього підтримує більшого функціоналу

Наприклад можливо просто створити невеличкий Dockerfile та вибрати основний образ VPN сервісу

- FROM ubuntu:latest

**Оновлення пакетів та встановлення залежностей**

- RUN apt-get update && \
apt-get install -y openvpn

Після чого можливо просто виконати команду білду після чого запуску

- docker build -t vpn-container .
- docker run --privileged -d --name vpn-container vpn-container

## Детальне встановлення VPN

Або розгорнути більш детально контейнер

- FROM ubuntu:latest

Оновлення пакетів та встановлення залежностей

- RUN apt-get update && \
apt-get install -y openvpn systemd curl && \
apt-get clean && \
rm -rf /var/lib/apt/lists/*

Завантаження та встановлення PIA VPN-клієнта

- RUN curl -O https://installers.privateinternetaccess.com/download/pia-linux-3.9-05654.run && \
chmod +x pia-linux-3.9-05654.run && \
./pia-linux-3.9-05654.run

Створення каталогу для конфігурації OpenVPN

- RUN mkdir -p /etc/openvpn

Копіювання конфігурації OpenVPN до каталогу

- COPY openvpn.conf /etc/openvpn/

Створення systemd service для OpenVPN

- COPY openvpn.service /etc/systemd/system/openvpn.service

Експорт портів для OpenVPN

- EXPOSE 1194/udp

Виконання служби ініціалізації

- CMD ["/lib/systemd/systemd"]

Даний Dockerfile робить наступне:

1. Оновлює пакети та встановлює необхідні залежності (OpenVPN, systemd, curl).
2. Завантажує та встановлює PIA VPN-клієнта.
3. Створює каталог `/etc/openvpn` та копіює конфігурацію OpenVPN до цього каталогу.
4. Створює systemd service для OpenVPN та копіює його до відповідного каталогу.
5. Експортує порт 1194/udp для використання OpenVPN.
6. Запускає службу ініціалізації systemd.

Після чого не потрібно забувати про конфігурацію VPC сервісу.

# Docker

Docker завоював широку популярність у розробницькому та інфраструктурному співтоваристві через кілька ключових переваг, які відзначають його серед інших інструментів для контейнеризації.

# Як працює Docker

Docker Compose або Kubernetes, які можуть надавати більше функціоналу для роботи з мережами та VPN. Наприклад, у Kubernetes можна використовувати мережеві поліції та мережеві механізми для роботи з VPN

### Docker Daemon (сервер)

Це основний процес, який працює на хост-системі. Він відповідає за керування контейнерами, образами, мережами та збереженими об'єктами Docker. Daemon надає REST API, яке може використовуватися для взаємодії з Docker через командний рядок або інші інструменти.

### Docker Client (клієнт)

Це інтерфейс користувача для взаємодії з Docker. Він може бути командним рядком (CLI) або графічним інтерфейсом (наприклад, Docker Desktop). Клієнт надсилає команди Docker Daemon через API, щоб керувати контейнерами, образами та іншими складовими Docker.

### Docker Registry (реєстр, компоненти)

Це централізоване місце для зберігання Docker-образів. Docker Hub є одним з публічних реєстрів, де розробники можуть знайти готові образи. Однак, Docker також підтримує приватні реєстри, які можуть бути використані для збереження власних образів.

До базових понять платформи належать:

1. Контейнер. Це ізольоване виконавче середовище, що містить програмне забезпечення та всі його залежності. Контейнери базуються на образах, що зберігають дані про файлів і конфігурацію для створення та запуску віртуальних ізольованих процесів.
2. Образ. Це шаблон для створення контейнера. Він містить код програми, середовище виконання, бібліотеки, залежності та інші компоненти, необхідні для виконання додатка.
3. Dockerfile. Це текстовий файл, в якому описуються інструкції для створення образу. В ньому вказані кроки для налаштування середовища, імпортування залежностей та копіювання коду додатка.
4. Реєстр. Це централізоване місце для зберігання та управління образами. Docker Hub є одним з найбільш популярних публічних реєстрів, де можна знайти готові образи, а також завантажити власні.
5. Compose. Це інструмент для визначення та управління багатьма контейнерами як однією програмою. Використовуючи файл docker-compose.yml, можна визначити конфігурацію додатка та його залежностей, що дозволяє запускати їх разом однією командою.
6. CLI. Це командний рядок інтерфейсу користувача для взаємодії з Docker. З його допомогою можна створювати, запускати, зупиняти, видаляти та управляти контейнерами й образами.
7. Docker Swarm (Docker Engine Swarm mode). Це вбудоване в Docker середовище для керування контейнерами в кластерному середовищі. Воно дозволяє об'єднати кілька Docker-хостів для створення високодоступних та масштабованих додатків.
8. Compose. Інструмент для визначення та управління багатьма контейнерами як однією програмою.

## Docker desktop

Docker Desktop включає в себе графічний інтерфейс для управління контейнерами, віртуальну машину для виконання контейнерів, інструменти для створення, редагування та запуску контейнерів, а також доступ до Docker Hub та інших ресурсів.

Docker Desktop використовує віртуальну машину (VM), яка встановлюється на вашому комп'ютері. Ця VM називається "Docker Desktop VM" або "MobyLinuxVM". Вона використовує Hyper-V на Windows або xhyve на macOS для створення ізольованого середовища, в якому виконуються контейнери. Також Docker Desktop надає графічний інтерфейс (GUI), який дозволяє користувачам легко керувати контейнерами. Цей інтерфейс включає в себе панель керування, де ви можете переглядати стан контейнерів, мереж, образів та іншого.

## Docker swam

Docker Swarm – це оркестратор від компанії Docker, який дозволяє об'єднувати кілька Docker-хостів у єдиний кластер та автоматично керувати запуском та масштабуванням контейнерів. За допомогою цього інструменту компанія може легко розгортати необхідні служби, керувати ними, масштабувати в процесі розвитку і моніторити стабільність і продуктивність.

У Docker Swarm є 2 основних типи вузлів:

Керуючі вузли (Managers).
Менеджери є керуючими вузлами у кластері Docker Swarm. Вони відповідають за прийняття рішень та координацію дій у кластері. Нижче наведемо основні завдання, які вирішують керуючі вузли:

Визначають, на яких робочих вузлах слід запускати контейнери на основі поточного навантаження та доступних ресурсів у кластері. Для оптимального розподілу контейнерів використовують алгоритми балансування навантаження.
Відповідають за створення, масштабування та оновлення сервісів у кластері.
Виконують моніторинг працездатності контейнерів та автоматично виявляють збої, щоб оперативно відновлювати працездатність додатків у разі несправностей.
Робочі сайти (Workers).
Робочі вузли виконують завдання, сформовані керуючими вузлами. Вони обробляють запити від менеджерів, отримують контейнери для виконання та звітують про стан контейнерів.

## Плюси Docker

- Docker пропонує простий та інтуїтивно зрозумілий інтерфейс для роботи з контейнерами. Він надає команди та інструменти, що полегшують розгортання та управління контейнерами.

- Docker контейнери є портативними та консистентними навколишніми середовищами. Це дозволяє розробникам пакувати всі залежності свого додатка в контейнер та переносити його між різними середовищами (розробка, тестування, продакшн) без зміни коду.

- Docker дозволяє швидко розгортати контейнери, оскільки вони запускаються на базовому ядрі операційної системи та використовують власний ізольований файловий та мережевий стек.

- Docker дозволяє легко масштабувати додатки, використовуючи контейнери та оркестраційні інструменти, такі як Docker Compose або Kubernetes. Це робить його ефективним для великих та розподілених систем.

- Docker має велике та активне співтовариство, що призвело до широкої підтримки, наявності різноманітних образів та інструментів в екосистемі Docker.

- Docker дотримується стандартів контейнерів, розроблених Open Container Initiative (OCI), що забезпечує сумісність із різними інструментами та сервісами.

- Docker використовує механізми ядра Linux, такі як namespaces та cgroups, для створення ізольованих середовищ, що дозволяє контейнерам працювати незалежно один від одного та забезпечує безпеку відокремленості.

- Docker має ряд додаткових сервісів та інструментів, таких як Docker Compose для локального розгортання, Docker Swarm для оркестрації та Docker Hub для зберігання та обміну Docker Images.

## Мінуси Docker

1. **Розмір образів:**
    - Образи Docker можуть бути великими, особливо якщо вони містять повноцінні операційні системи та всі необхідні залежності. Це може призвести до зайвого споживання дискового простору та тривалих часів завантаження, особливо при обміні образами через мережу.
2. **Засіб PID 1:**
    - Контейнери Docker запускають один процес (PID 1) у своєму внутрішньому просторі, і цей процес відповідає за виконання завдань, таких як обробка сигналів. Проблеми можуть виникнути, якщо програма в контейнері не призначена для роботи як PID 1, оскільки це може вплинути на обробку сигналів та контроль за завданнями.
3. **Нестабільність API:**
    - API Docker може бути нестабільним у деяких версіях. Це може призвести до проблем з сумісністю та роботою інструментів, побудованих на основі Docker API.
4. **Споживання ресурсів:**
    - Docker може споживати значну кількість ресурсів, особливо якщо запущено багато контейнерів на одному хості. Це може призвести до конфліктів та впливу на продуктивність інших додатків на хості.
5. **Проблеми із забезпеченням:**
    - Хоча Docker докладає багато зусиль для забезпечення контейнерів, існують ризики, пов'язані з використанням контейнерів, такі як можливість використання вразливостей в системі або неправильна конфігурація контейнера.
6. **Специфічність для Linux:**
    - Docker спочатку розроблявся для Linux і пізніше був портований на інші платформи. Це може призвести до проблем з сумісністю та обмежити його ефективність на платформах, інших за Linux.

# Як Docker працює з VPN

За допомогою Docker Compose ви можете створювати складні стеки контейнерів та визначати мережеві служби. Можливо  створити окремий контейнер для VPN та додати його до мережі, якою використовуються інші контейнери. Це дозволяє легко організувати спільний доступ до VPN для всіх контейнерів

Як приклад можливо взяти:

- Version: ‘3’
- Service:
    
    vpn:
    
    image: hwd12/ipsec-vpn-server
    
    restart: always
    
    environment:
    
    -VPN_IPSEC_PSK=my-shared-secret
    
    -VPN_USER=my-username
    
    -VPN_PASWWORD=my-password
    
    ports:
    
    -”500:500/udp”
    
    -”4500:4500/udp”
    
    privileged: true
    

Після чого слід не забувати про конфігурацію.

# Linux Containers

LXC або Linux Containers — одна з найдавніших систем для роботи з контейнерами, проте і досі залишається дуже поширеною. Платформа доступна лише для Linux та вже вбудована в Ubuntu.

Абревіатура розшифровується просто Linux Container. Це контейнерна система віртуалізації, що діє у межах операційної системи Linux. Що це означає? З LXC можна запустити кілька повністю ізольованих та незалежних один від одного екземплярів ОС Linux на одному комп'ютері. Крім цього є можливість створити надійний кластер з декількох десятків серверів, коли один і той же екземляпр контейнера виконується відразу на декількох фізичних машинах і у разі виходу з ладу одного сервера робота контейнера не зупиняється ні на хвилину. Так само дані контейнера знаходяться одразу на кількох сховищах, реалізується це різними методами (ceph). Що дозволяє окрім живої міграції контейнера між нодами кластера, так само ще більше підвищити надійність зберігання даних, гнучко збільшувати дискову підсистему контейнера в межах.

Програма — беpзкоштовна. Проте, щоб створювати контейнери, вам знадобиться ядро  Linux 3.8 або новіше. LXC складніший у використанні, ніж Docker, що пояснює чому другий є беззаперечним лідером.

## Різниця між LXC та Docker

- Docker – це контейнер для упаковки одного процесу чи служби;
на практиці Docker – це пачка легких контейнерів для упаковки одного веб-сервісу;
- LXC – це легкий контейнер на один веб-сервіс або сайт, що включає всі служби, які потрібні для його функціонування.

У яких випадках зручно застосовувати LXC:

- Legacy: у вас вже є веб-сервіс/сайт розміщений на виділеному сервері і потрібно запакувати його у формі контейнера, який можна віддати розробникам, або перенести на інший сервер (резервний чи stage);
- Вам подобається працювати в оточенні, де всі служби зібрані в одному контейнері;
- Потрібна ізоляція на сервері, щоб кожен веб-сервіс знаходився у своєму контейнері, але при цьому не втрачати продуктивність як у випадку з віртуальними машинами;
- Якщо ви вмієте налаштовувати основні сервіси в Linux, ви зможете створити LXC контейнер під ваш проект. LXC дуже схожий на звичайну віртуалку.

## Основні команди LXC

Важливою частиною виділити, що LXC використовує тільки дистрибутиви Linux.

Встановлення та налаштування Linux Containers (LXC) зазвичай включає в себе декілька кроків, а також слід визначити основні команди для програмного забезбеченння:

- sudo apt install lxc - встановлення пакетів LXC
- lxd init - для ініціалізації та конфігурації LXC
- lxc launch <ім'я_образу> <ім'я_контейнера> - створення контейнера
- lxc list - список контейнерів
- lxc exec <ім'я_контейнера> -- /bin/bash - ввійти в контейнер
- lxc exec mycontainer -- /bin/bash - Ввійти в контейнер
- lxc info <ім'я_контейнера> - Вивести інформацію про контейнер
- lxc stop <ім'я_контейнера> - Зупинити контейнер
- lxc suspend <ім'я_контейнера> - Призупинити контейнер
- lxc delete <ім'я_контейнера> - Видалити контейнер
- lxc logs <ім'я_контейнера> - Вивести журнали контейнера

## Плюси використання LXC

1. **Легкість використання:**
    
    LXC включає зручний інтерфейс командного рядка, який дозволяє легко створювати, запускати та управляти контейнерами. Команди LXC досить інтуїтивно зрозумілі.
    
2. **Ефективне використання ресурсів:**
    
    Контейнери LXC використовують спільні ядра з хост-системою, що дозволяє їм ефективно використовувати системні ресурси та зменшує накладні витрати.
    
3. **Ізоляція ресурсів:**
    
    Контейнери LXC дозволяють ізолювати ресурси, такі як CPU, пам'ять та мережа, для забезпечення надійності та безпеки роботи контейнера.
    
4. **Мобільність:**
    
    Контейнери LXC можна легко переносити між різними середовищами, такими як розробка, тестування та виробництво, забезпечуючи консистентність робочого середовища.
    
5. **Легкість розгортання та швидкість запуску:**
    
    Створення та розгортання контейнерів LXC є швидким та займає мінімальний час порівняно зі створенням віртуальних машин.
    
6. **Використання технології ядра Linux cgroups та namespaces:**
    
    LXC використовує функціонал ядра Linux, такий як cgroups та namespaces, для забезпечення ізоляції та управління ресурсами.
    
7. **Спрощене управління ресурсами:**
    
    LXC дозволяє контролювати та обмежувати доступ до ресурсів, таких як CPU, пам'ять, мережа, що робить управління ресурсами більш простим та ефективним.
    

## Мінуси використання LXC

1. **Менша ізоляція:**
    
    Одним з головних мінусів LXC є менша ізоляція порівняно з традиційними віртуальними машинами. Контейнери LXC використовують спільне ядро з хост-системою, тому існує деяка можливість витоку даних між контейнерами.
    
2. **Більше можливостей для атак:**
    
    Оскільки контейнери використовують спільне ядро, вразливості в ядрі можуть стати потенційною точкою входу для атак на всі контейнери та хост-систему.
    
3. **Обмежена підтримка для різних ОС:**
    
    Хоча LXC підтримує різні дистрибутиви Linux, використання інших операційних систем у контейнерах може бути викликаною проблемою.
    
4. **Брак підтримки для Windows:**
    
    LXC спеціалізується на підтримці Linux-контейнерів, і він не надає підтримки для контейнерів, що використовують операційні системи Windows.
    
5. **Відсутність графічного інтерфейсу:**
    
    У порівнянні з іншими системами віртуалізації, такими як VirtualBox або VMware, LXC не надає графічного інтерфейсу для управління контейнерами, що може зробити його менш зручним для користувачів, які полюбляють візуальне управління.
    

## Архітектура LXC

Задана архітектура дозволяє LXC створювати та управляти ізольованими контейнерами, які мають свої власні середовища та ресурси, використовуючи спільне ядро з хост-системою.

- Хост-система - це операційна система, на якій запущений LXC. Вона надає базове середовище для роботи та управління контейнерами.
- LXC Daemon (lxc.service) - це служба, яка виконується на хост-системі і відповідає за управління контейнерами. Вона обробляє запити від користувачів, розгортає та управляє контейнерами.
- LXC надає інструментарій командного рядка для взаємодії з LXC Daemon та управління контейнерами. До цього інструментарію входять команди, такі як **`lxc-create`** для створення контейнера, **`lxc-start`** для запуску, та інші.
- Кожен контейнер має свій власний файл конфігурації, який визначає його параметри, такі як образ базової системи, ізольовані ресурси, мережеві налаштування та інші.
- Контейнери LXC використовують ядро Linux, яке надає підтримку для використання технологій, таких як cgroups та namespaces, для забезпечення ізоляції та управління ресурсами.
- Внутрішньо контейнери використовують cgroups та namespaces для ізоляції та управління ресурсами. Кожен контейнер має свої області ізоляції для процесів, мережі, файлової системи тощо.

## LXC з VPC

Як приклад можливо навести з VPN WireGuard

Спочатку слід встановити на хост- систему , тобто на ОС

- sudo apt install wireguard

Або також можливо встановити його в контейнер

- apt install wireguard-tools

Після чого створити ``конфі. файл в WireGuard на хост-системі. Використовуйте текстовий редактор, такий як **nano** або **vi**, для створення файлу конфігурації (наприклад, **/etc/wireguard/wg0.conf**). 

- [Interface]
Address = 10.0.0.1/24
PrivateKey = <приватний_ключ_хоста>
ListenPort = 51820
- [Peer]
PublicKey = <публічний_ключ_клієнта>
AllowedIPs = 10.0.0.2/32  (наведено як приклад)

Та почати запуск на хост системі

- sudo wg-quick up wg0

Після чого потрібно налаштувати мережу в контейнері VPN, тому для початку варто зайти в контейнер та налаштувати мережу.

- sudo lxc exec <ім'я_контейнера> -- /bin/bash - підключення до контейнеру
- apt update
apt install wireguard-tools

Та Виконати наступні команди для конфігурації, де вставляємо відповідні значення.

- ip link add dev wg0 type wireguard
ip address add dev wg0 10.0.0.2/24
wg set wg0 private-key <приватний_ключ_клієнта>
wg set wg0 peer <публічний_ключ_хоста> endpoint <IP_адреса_хоста>:51820
ip link set up dev wg0

Після правильного виконання, виконуємо команду “wg show” та перевірити правильність конфігорування контейнеру.
